<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Transformation Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Strict lockdown of the viewport to prevent iPad "rubber-banding" */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
            background-color: #f8fafc;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 55vh;
            background-color: #ffffff;
            border-bottom: 2px solid #e2e8f0;
            overflow: hidden;
            touch-action: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .modal.active { display: flex; }
        
        button, input {
            user-select: auto;
            -webkit-user-select: auto;
            touch-action: manipulation; 
        }
        
        .controls-area {
            flex-grow: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            padding: 1rem;
        }

        /* Improved labels for high-dpi mobile screens */
        .coord-label {
            pointer-events: none;
            text-shadow: 0 0 4px white, 0 0 4px white;
        }
    </style>
</head>
<body class="font-sans">

    <header class="p-4 bg-white border-b border-slate-200 shadow-sm shrink-0">
        <h1 class="text-xl font-bold text-slate-800 text-center">Transformation Lab</h1>
        <div class="mt-1 flex justify-center gap-4 text-xs font-mono font-bold">
            <div class="text-blue-600">Crosshair: (<span id="val-x">0</span>, <span id="val-y">0</span>)</div>
            <div id="status-msg" class="text-slate-500 italic truncate max-w-[150px]">Place Pre-Image points.</div>
        </div>
    </header>

    <main class="flex-grow flex flex-col overflow-hidden">
        <div class="canvas-container shrink-0" id="container">
            <canvas id="gridCanvas"></canvas>
        </div>

        <div class="controls-area">
            <div class="bg-white p-4 rounded-2xl border border-slate-200 shadow-sm max-w-2xl mx-auto">
                <div class="flex justify-center gap-2 mb-4 bg-slate-100 p-1 rounded-xl">
                    <button id="mode-pre" class="flex-1 py-2 rounded-lg font-bold bg-blue-600 text-white shadow-sm transition-colors">1. Pre-Image</button>
                    <button id="mode-img" class="flex-1 py-2 rounded-lg font-bold text-slate-600 transition-colors">2. Image</button>
                </div>

                <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-4">
                    <button onclick="openModal('translateModal')" class="p-3 bg-indigo-50 text-indigo-700 rounded-xl font-bold border border-indigo-100 active:bg-indigo-100">Translate</button>
                    <button onclick="openModal('rotateModal')" class="p-3 bg-amber-50 text-amber-700 rounded-xl font-bold border border-amber-100 active:bg-amber-100">Rotate</button>
                    <button onclick="openModal('reflectModal')" class="p-3 bg-emerald-50 text-emerald-700 rounded-xl font-bold border border-emerald-100 active:bg-emerald-100">Reflect</button>
                    <button id="btn-check" class="p-3 bg-slate-800 text-white rounded-xl font-bold shadow-lg active:bg-slate-700 transition-transform active:scale-95">
                        Check Work
                    </button>
                </div>

                <div class="flex gap-2 justify-center">
                    <button id="btn-clear" class="px-6 py-2 bg-red-50 text-red-600 rounded-lg text-sm font-bold border border-red-100">Clear All</button>
                </div>
            </div>
        </div>
    </main>

    <!-- Modals -->
    <div id="translateModal" class="modal p-4" onclick="closeModal()">
        <div class="bg-white p-6 rounded-2xl w-full max-w-sm" onclick="event.stopPropagation()">
            <h2 class="text-xl font-bold mb-4">Translate</h2>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-bold text-slate-600">Horizontal (x)</label>
                    <input type="number" id="transX" value="0" step="0.5" class="w-full p-3 bg-slate-50 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-bold text-slate-600">Vertical (y)</label>
                    <input type="number" id="transY" value="0" step="0.5" class="w-full p-3 bg-slate-50 border rounded-lg">
                </div>
                <button onclick="setTransformation('translate')" class="w-full bg-indigo-600 text-white py-3 rounded-xl font-bold">Apply Transformation</button>
                <button onclick="closeModal()" class="w-full text-slate-400 font-bold py-2">Cancel</button>
            </div>
        </div>
    </div>

    <div id="rotateModal" class="modal p-4" onclick="closeModal()">
        <div class="bg-white p-6 rounded-2xl w-full max-w-sm" onclick="event.stopPropagation()">
            <h2 class="text-xl font-bold mb-4">Rotate about (0,0)</h2>
            <div class="grid grid-cols-2 gap-2 mb-4">
                <button onclick="setTransformation('rotate', 90)" class="p-4 border rounded-xl font-bold bg-slate-50">90째 CW</button>
                <button onclick="setTransformation('rotate', -90)" class="p-4 border rounded-xl font-bold bg-slate-50">90째 CCW</button>
                <button onclick="setTransformation('rotate', 180)" class="p-4 border rounded-xl font-bold bg-slate-50">180째</button>
                <button onclick="setTransformation('rotate', 270)" class="p-4 border rounded-xl font-bold bg-slate-50">270째 CW</button>
            </div>
            <button onclick="closeModal()" class="w-full text-slate-400 font-bold py-2">Cancel</button>
        </div>
    </div>

    <div id="reflectModal" class="modal p-4" onclick="closeModal()">
        <div class="bg-white p-6 rounded-2xl w-full max-w-sm" onclick="event.stopPropagation()">
            <h2 class="text-xl font-bold mb-4">Reflect</h2>
            <div class="space-y-2">
                <button onclick="setTransformation('reflect', 'x')" class="w-full p-4 border rounded-xl font-bold">Across X-Axis</button>
                <button onclick="setTransformation('reflect', 'y')" class="w-full p-4 border rounded-xl font-bold">Across Y-Axis</button>
                <button onclick="setTransformation('reflect', 'custom')" class="w-full p-4 border rounded-xl bg-emerald-50 text-emerald-700 font-bold">Custom Line</button>
                <button onclick="closeModal()" class="w-full text-slate-400 font-bold py-2 mt-2">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('container');
        const valX = document.getElementById('val-x');
        const valY = document.getElementById('val-y');
        const statusMsg = document.getElementById('status-msg');

        let prePoints = [];
        let imgPoints = [];
        let targetPoints = [];
        let reflectionLine = null;
        let currentMode = 'pre'; 
        let gridSize = 25;
        let origin = { x: 0, y: 0 };
        const SNAP = 0.5;

        let isAnimatingCheck = false;
        let isRotating = false;
        let rotationTargetAngle = 0; 
        let rotationProgress = 0;

        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            // Interaction logic
            const getPos = (e) => {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: clientX - rect.left, y: clientY - rect.top };
            };

            const handleMove = (e) => {
                const pos = getPos(e);
                const cart = toCartesian(pos.x, pos.y);
                valX.textContent = cart.x;
                valY.textContent = cart.y;
            };

            const handleEnd = (e) => {
                const pos = getPos(e.changedTouches ? e.changedTouches[0] : e);
                const cart = toCartesian(pos.x, pos.y);

                if (currentMode === 'reflect-line') {
                    if (!reflectionLine) reflectionLine = [];
                    reflectionLine.push(cart);
                    if (reflectionLine.length === 2) calculateCustomReflection();
                } else {
                    let list = currentMode === 'pre' ? prePoints : imgPoints;
                    const idx = list.findIndex(p => Math.abs(p.x - cart.x) < 0.2 && Math.abs(p.y - cart.y) < 0.2);
                    if (idx !== -1) list.splice(idx, 1);
                    else list.push(cart);
                    isAnimatingCheck = false;
                    isRotating = false;
                }
            };

            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mousedown', (e) => {}); // placeholder
            canvas.addEventListener('mouseup', handleEnd);

            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleMove(e); }, {passive:false});
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); }, {passive:false});
            canvas.addEventListener('touchend', (e) => { e.preventDefault(); handleEnd(e); }, {passive:false});

            document.getElementById('mode-pre').onclick = () => switchWorkflow('pre');
            document.getElementById('mode-img').onclick = () => switchWorkflow('img');
            document.getElementById('btn-clear').onclick = clearAll;
            document.getElementById('btn-check').onclick = checkWork;
            
            requestAnimationFrame(gameLoop);
        }

        function gameLoop() {
            draw();
            requestAnimationFrame(gameLoop);
        }

        function switchWorkflow(mode) {
            currentMode = mode;
            isAnimatingCheck = false;
            isRotating = false;
            const preBtn = document.getElementById('mode-pre');
            const imgBtn = document.getElementById('mode-img');
            preBtn.className = currentMode === 'pre' ? "flex-1 py-2 rounded-lg font-bold bg-blue-600 text-white shadow-sm" : "flex-1 py-2 rounded-lg font-bold text-slate-600";
            imgBtn.className = currentMode === 'img' ? "flex-1 py-2 rounded-lg font-bold bg-blue-600 text-white shadow-sm" : "flex-1 py-2 rounded-lg font-bold text-slate-600";
            statusMsg.textContent = currentMode === 'pre' ? "Place Pre-Image points." : "Draw the resulting Image.";
        }

        function openModal(id) { document.getElementById(id).classList.add('active'); }
        function closeModal() { document.querySelectorAll('.modal').forEach(m => m.classList.remove('active')); }

        function clearAll() {
            prePoints = []; imgPoints = []; targetPoints = []; reflectionLine = null;
            isAnimatingCheck = false; isRotating = false;
            switchWorkflow('pre');
        }

        function setTransformation(type, val) {
            if (prePoints.length === 0) { alert("Draw a Pre-Image first!"); closeModal(); return; }
            targetPoints = []; reflectionLine = null; isAnimatingCheck = false; isRotating = false;

            if (type === 'translate') {
                const dx = parseFloat(document.getElementById('transX').value) || 0;
                const dy = parseFloat(document.getElementById('transY').value) || 0;
                targetPoints = prePoints.map(p => ({ x: p.x + dx, y: p.y + dy }));
            } else if (type === 'rotate') {
                targetPoints = prePoints.map(p => {
                    if (val === 90) return { x: p.y, y: -p.x };
                    if (val === -90) return { x: -p.y, y: p.x };
                    if (val === 180) return { x: -p.x, y: -p.y };
                    if (val === 270) return { x: -p.y, y: p.x };
                    return p;
                });
                isRotating = true; rotationProgress = 0; rotationTargetAngle = -(val * Math.PI / 180);
            } else if (type === 'reflect') {
                if (val === 'x') targetPoints = prePoints.map(p => ({ x: p.x, y: -p.y }));
                else if (val === 'y') targetPoints = prePoints.map(p => ({ x: -p.x, y: p.y }));
                else if (val === 'custom') { currentMode = 'reflect-line'; closeModal(); return; }
            }
            switchWorkflow('img'); closeModal();
        }

        function calculateCustomReflection() {
            const p1 = reflectionLine[0], p2 = reflectionLine[1];
            targetPoints = prePoints.map(p => {
                const dx = p2.x - p1.x, dy = p2.y - p1.y;
                if (dx === 0 && dy === 0) return p;
                const a = dy, b = -dx, c = dx * p1.y - dy * p1.x;
                const d = (a * p.x + b * p.y + c) / (a * a + b * b);
                return { x: p.x - 2 * a * d, y: p.y - 2 * b * d };
            });
            switchWorkflow('img');
        }

        function checkWork() {
            if (targetPoints.length === 0) { alert("Set a transformation first!"); return; }
            isAnimatingCheck = true;
            if (imgPoints.length !== targetPoints.length) {
                statusMsg.innerHTML = `<span class='text-amber-600 font-bold'>Need ${targetPoints.length} points.</span>`;
                return;
            }
            let correct = 0;
            targetPoints.forEach(tp => {
                if (imgPoints.some(ip => Math.abs(ip.x - tp.x) < 0.25 && Math.abs(ip.y - tp.y) < 0.25)) correct++;
            });
            statusMsg.innerHTML = correct === targetPoints.length ? "<span class='text-emerald-600 font-bold'>Correct!</span>" : `<span class='text-red-600 font-bold'>Score: ${correct}/${targetPoints.length}</span>`;
        }

        function resize() {
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width * devicePixelRatio;
            canvas.height = rect.height * devicePixelRatio;
            ctx.scale(devicePixelRatio, devicePixelRatio);
            origin.x = rect.width / 2;
            origin.y = rect.height / 2;
            gridSize = Math.max(18, Math.floor(Math.min(rect.width, rect.height) / 35)); 
        }

        function toCartesian(px, py) {
            return { x: Math.round((px - origin.x) / gridSize / SNAP) * SNAP, y: Math.round((origin.y - py) / gridSize / SNAP) * SNAP };
        }

        function toPixels(cx, cy) {
            return { x: origin.x + (cx * gridSize), y: origin.y - (cy * gridSize) };
        }

        function drawShape(list, color, labelPrefix, alpha = 1) {
            if (list.length === 0) return;
            ctx.save();
            ctx.globalAlpha = alpha;
            
            // Draw lines
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            list.forEach((p, i) => {
                const pix = toPixels(p.x, p.y);
                if (i === 0) ctx.moveTo(pix.x, pix.y);
                else ctx.lineTo(pix.x, pix.y);
            });
            if(list.length > 2) ctx.closePath();
            ctx.stroke();

            // Draw points and labels
            list.forEach((p, i) => {
                const pix = toPixels(p.x, p.y);
                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.arc(pix.x, pix.y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // FIX FOR iOS: Force High-Contrast Labels
                ctx.save();
                ctx.globalAlpha = 1.0; 
                ctx.font = 'bold 12px monospace';
                ctx.textAlign = 'center';
                
                // White glow/outline for legibility
                ctx.shadowColor = 'white';
                ctx.shadowBlur = 4;
                ctx.fillStyle = '#000000';
                
                // Vertex label (P1)
                ctx.fillText(`${labelPrefix}${i+1}`, pix.x, pix.y - 24);
                
                // Coordinates (x, y)
                ctx.font = 'bold 10px monospace';
                ctx.fillText(`(${p.x}, ${p.y})`, pix.x, pix.y - 12);
                ctx.restore();
            });
            ctx.restore();
        }

        function draw() {
            const w = canvas.width / devicePixelRatio;
            const h = canvas.height / devicePixelRatio;
            ctx.clearRect(0, 0, w, h);
            
            // Grid
            ctx.beginPath(); ctx.strokeStyle = '#f1f5f9'; ctx.lineWidth = 1;
            for (let x = -20; x <= 20; x += 0.5) { let p = toPixels(x,0); ctx.moveTo(p.x,0); ctx.lineTo(p.x,h); }
            for (let y = -20; y <= 20; y += 0.5) { let p = toPixels(0,y); ctx.moveTo(0,p.y); ctx.lineTo(w,p.y); }
            ctx.stroke();

            ctx.beginPath(); ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1.5;
            for (let x = -20; x <= 20; x += 1) { let p = toPixels(x,0); ctx.moveTo(p.x,0); ctx.lineTo(p.x,h); }
            for (let y = -20; y <= 20; y += 1) { let p = toPixels(0,y); ctx.moveTo(0,p.y); ctx.lineTo(w,p.y); }
            ctx.stroke();

            ctx.beginPath(); ctx.strokeStyle = '#475569'; ctx.lineWidth = 2.5;
            ctx.moveTo(0, origin.y); ctx.lineTo(w, origin.y);
            ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, h);
            ctx.stroke();

            // Axis Text
            ctx.fillStyle = '#94a3b8'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
            for (let x = -20; x <= 20; x += 2) { if(x!==0){ let p = toPixels(x,0); ctx.fillText(x, p.x, origin.y+14); } }
            for (let y = -20; y <= 20; y += 2) { if(y!==0){ let p = toPixels(0,y); ctx.fillText(y, origin.x-10, p.y+4); } }

            if (reflectionLine) {
                ctx.setLineDash([5, 5]); ctx.strokeStyle = '#10b981'; ctx.lineWidth = 2;
                if (reflectionLine.length === 2) {
                    const dx = reflectionLine[1].x - reflectionLine[0].x, dy = reflectionLine[1].y - reflectionLine[0].y;
                    const s = toPixels(reflectionLine[0].x - dx*50, reflectionLine[0].y - dy*50), e = toPixels(reflectionLine[0].x + dx*50, reflectionLine[0].y + dy*50);
                    ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y); ctx.stroke();
                }
                ctx.setLineDash([]);
            }

            drawShape(prePoints, '#3b82f6', 'P');

            if (isRotating && prePoints.length > 0) {
                rotationProgress = Math.min(1, rotationProgress + 0.015);
                const a = rotationTargetAngle * rotationProgress;
                const rp = prePoints.map(p => ({ x: p.x * Math.cos(a) - p.y * Math.sin(a), y: p.x * Math.sin(a) + p.y * Math.cos(a) }));
                drawShape(rp, '#f59e0b', "R", 0.4);
            }

            if (isAnimatingCheck && targetPoints.length > 0) {
                drawShape(targetPoints, '#10b981', "T", 0.3);
                targetPoints.forEach(tp => {
                    const pix = toPixels(tp.x, tp.y);
                    const isCorrect = imgPoints.some(ip => Math.abs(ip.x - tp.x) < 0.25 && Math.abs(ip.y - tp.y) < 0.25);
                    ctx.beginPath(); ctx.strokeStyle = isCorrect ? '#10b981' : '#f43f5e';
                    ctx.lineWidth = 2; ctx.arc(pix.x, pix.y, 12, 0, Math.PI * 2); ctx.stroke();
                });
            }

            drawShape(imgPoints, '#ef4444', "P'");
        }
        
        window.onload = init;
    </script>
</body>
</html>
