<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Transformation Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Strict lockdown of the viewport to prevent iPad "rubber-banding" or scrolling */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed; /* Essential for iOS scroll locking */
            touch-action: none; /* Disables browser-level gestures like pinch/zoom/scroll */
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            background-color: #f8fafc;
            display: flex;
            flex-direction: column;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 55vh;
            background-color: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
            cursor: crosshair;
            touch-action: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .modal.active { display: flex; }
        
        /* Re-enable interaction for buttons/inputs */
        button, input {
            user-select: auto;
            -webkit-user-select: auto;
            touch-action: manipulation; 
        }
        
        /* Custom scroll for the controls area if it overflows on small screens */
        .controls-area {
            flex-grow: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y; 
            padding-bottom: 2rem;
        }
    </style>
</head>
<body class="font-sans">

    <!-- Header & Display -->
    <header class="p-4 bg-white border-b border-slate-200 shadow-sm shrink-0">
        <h1 class="text-xl font-bold text-slate-800 text-center">Transformation Lab</h1>
        <div class="mt-2 flex justify-center gap-6 text-sm font-mono font-bold">
            <div class="text-blue-600">Current: (<span id="val-x">0</span>, <span id="val-y">0</span>)</div>
            <div id="status-msg" class="text-slate-500 italic text-center max-w-xs">Place points for your Pre-Image.</div>
        </div>
    </header>

    <!-- Main Workspace -->
    <main class="flex-grow flex flex-col p-4 gap-4 overflow-hidden">
        <div class="canvas-container shadow-inner shrink-0" id="container">
            <canvas id="gridCanvas"></canvas>
        </div>

        <!-- Controls Area -->
        <div class="controls-area">
            <div class="bg-white p-4 rounded-2xl border border-slate-200 shadow-sm">
                <!-- Mode Selector -->
                <div class="flex justify-center gap-2 mb-4 bg-slate-100 p-1 rounded-xl">
                    <button id="mode-pre" class="flex-1 py-2 rounded-lg font-bold bg-blue-600 text-white shadow-sm">1. Pre-Image</button>
                    <button id="mode-img" class="flex-1 py-2 rounded-lg font-bold text-slate-600">2. Image</button>
                </div>

                <!-- Action Buttons -->
                <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-4">
                    <button onclick="openModal('translateModal')" class="p-3 bg-indigo-50 text-indigo-700 rounded-xl font-bold border border-indigo-100 active:scale-95 transition-all">Translate</button>
                    <button onclick="openModal('rotateModal')" class="p-3 bg-amber-50 text-amber-700 rounded-xl font-bold border border-amber-100 active:scale-95 transition-all">Rotate</button>
                    <button onclick="openModal('reflectModal')" class="p-3 bg-emerald-50 text-emerald-700 rounded-xl font-bold border border-emerald-100 active:scale-95 transition-all">Reflect</button>
                    <button id="btn-check" class="p-3 bg-slate-800 text-white rounded-xl font-bold shadow-lg active:scale-95 transition-all relative overflow-hidden">
                        Check Work
                    </button>
                </div>

                <div class="flex gap-2 justify-center">
                    <button id="btn-clear" class="px-6 py-2 bg-red-50 text-red-600 rounded-lg text-sm font-bold border border-red-100">Clear Everything</button>
                </div>
                <p class="text-center text-[10px] text-slate-400 mt-3">Tip: Tap once to add/remove points. Coordinates appear above each vertex.</p>
            </div>
        </div>
    </main>

    <!-- Modals -->
    <div id="translateModal" class="modal p-4" onclick="closeModal()">
        <div class="bg-white p-6 rounded-2xl w-full max-w-sm" onclick="event.stopPropagation()">
            <h2 class="text-xl font-bold mb-4">Translate</h2>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-bold text-slate-600">Left / Right (x)</label>
                    <input type="number" id="transX" value="0" step="0.5" class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-bold text-slate-600">Up / Down (y)</label>
                    <input type="number" id="transY" value="0" step="0.5" class="w-full p-2 border rounded-lg">
                </div>
                <button onclick="setTransformation('translate')" class="w-full bg-indigo-600 text-white py-3 rounded-xl font-bold">Set Target</button>
                <button onclick="closeModal()" class="w-full text-slate-400 font-bold py-1">Cancel</button>
            </div>
        </div>
    </div>

    <div id="rotateModal" class="modal p-4" onclick="closeModal()">
        <div class="bg-white p-6 rounded-2xl w-full max-w-sm" onclick="event.stopPropagation()">
            <h2 class="text-xl font-bold mb-4">Rotate about (0,0)</h2>
            <div class="grid grid-cols-2 gap-2 mb-4">
                <button onclick="setTransformation('rotate', 90)" class="p-3 border rounded-xl hover:bg-slate-50">90° CW</button>
                <button onclick="setTransformation('rotate', -90)" class="p-3 border rounded-xl hover:bg-slate-50">90° CCW</button>
                <button onclick="setTransformation('rotate', 180)" class="p-3 border rounded-xl hover:bg-slate-50">180°</button>
                <button onclick="setTransformation('rotate', 270)" class="p-3 border rounded-xl hover:bg-slate-50">270° CW</button>
            </div>
            <button onclick="closeModal()" class="w-full text-slate-400 font-bold py-1">Cancel</button>
        </div>
    </div>

    <div id="reflectModal" class="modal p-4" onclick="closeModal()">
        <div class="bg-white p-6 rounded-2xl w-full max-w-sm" onclick="event.stopPropagation()">
            <h2 class="text-xl font-bold mb-4">Reflect</h2>
            <div class="space-y-2">
                <button onclick="setTransformation('reflect', 'x')" class="w-full p-3 border rounded-xl hover:bg-slate-50">Across X-Axis</button>
                <button onclick="setTransformation('reflect', 'y')" class="w-full p-3 border rounded-xl hover:bg-slate-50">Across Y-Axis</button>
                <button onclick="setTransformation('reflect', 'custom')" class="w-full p-3 border rounded-xl bg-emerald-50 text-emerald-700 font-bold">Draw Custom Line</button>
                <button onclick="closeModal()" class="w-full text-slate-400 font-bold py-2 mt-2">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('container');
        const valX = document.getElementById('val-x');
        const valY = document.getElementById('val-y');
        const statusMsg = document.getElementById('status-msg');

        let prePoints = [];
        let imgPoints = [];
        let targetPoints = [];
        let reflectionLine = null;
        let lastPointerPos = { x: 0, y: 0 };
        let isHovering = false;
        
        let currentMode = 'pre'; 
        let gridSize = 25;
        let origin = { x: 0, y: 0 };
        const SNAP = 0.5;

        // Animation state
        let isAnimatingCheck = false;
        let isRotating = false;
        let rotationTargetAngle = 0; 
        let rotationProgress = 0;

        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            // Mouse Events
            canvas.addEventListener('mouseup', handlePointerUp);
            canvas.addEventListener('mousemove', (e) => {
                isHovering = true;
                handlePointerMove(e);
            });
            canvas.addEventListener('mouseleave', () => isHovering = false);
            
            // Touch Events (iPad Lockdown)
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                isHovering = true;
                handlePointerMove(e.touches[0]);
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault(); 
                handlePointerMove(e.touches[0]);
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                handlePointerUp(null); 
            }, { passive: false });

            // Universal Scroll Prevention except in specific area
            document.addEventListener('touchmove', (e) => {
                if (!e.target.closest('.controls-area')) {
                    e.preventDefault();
                }
            }, { passive: false });

            document.getElementById('mode-pre').onclick = () => switchWorkflow('pre');
            document.getElementById('mode-img').onclick = () => switchWorkflow('img');
            document.getElementById('btn-clear').onclick = clearAll;
            document.getElementById('btn-check').onclick = checkWork;
            
            requestAnimationFrame(gameLoop);
        }

        function gameLoop() {
            draw();
            requestAnimationFrame(gameLoop);
        }

        function switchWorkflow(mode) {
            currentMode = mode;
            isAnimatingCheck = false;
            isRotating = false;
            updateUI();
        }

        function updateUI() {
            const preBtn = document.getElementById('mode-pre');
            const imgBtn = document.getElementById('mode-img');
            preBtn.className = currentMode === 'pre' ? "flex-1 py-2 rounded-lg font-bold bg-blue-600 text-white shadow-sm" : "flex-1 py-2 rounded-lg font-bold text-slate-600";
            imgBtn.className = currentMode === 'img' ? "flex-1 py-2 rounded-lg font-bold bg-blue-600 text-white shadow-sm" : "flex-1 py-2 rounded-lg font-bold text-slate-600";
            
            if(currentMode === 'pre') statusMsg.textContent = "Place points for your Pre-Image.";
            else if(currentMode === 'img') statusMsg.textContent = "Draw the resulting Image.";
        }

        function openModal(id) { document.getElementById(id).classList.add('active'); }
        function closeModal() { document.querySelectorAll('.modal').forEach(m => m.classList.remove('active')); }

        function clearAll() {
            prePoints = [];
            imgPoints = [];
            targetPoints = [];
            reflectionLine = null;
            isAnimatingCheck = false;
            isRotating = false;
            switchWorkflow('pre');
        }

        function setTransformation(type, val) {
            if (prePoints.length === 0) {
                alert("Please draw a Pre-Image first!");
                closeModal();
                return;
            }
            targetPoints = [];
            reflectionLine = null;
            isAnimatingCheck = false;
            isRotating = false;

            if (type === 'translate') {
                const dx = parseFloat(document.getElementById('transX').value);
                const dy = parseFloat(document.getElementById('transY').value);
                targetPoints = prePoints.map(p => ({ x: p.x + dx, y: p.y + dy }));
                statusMsg.textContent = `Translate: (${dx}, ${dy})`;
            } 
            else if (type === 'rotate') {
                targetPoints = prePoints.map(p => {
                    if (val === 90) return { x: p.y, y: -p.x };
                    if (val === -90) return { x: -p.y, y: p.x };
                    if (val === 180) return { x: -p.x, y: -p.y };
                    if (val === 270) return { x: -p.y, y: p.x };
                    return p;
                });
                isRotating = true;
                rotationProgress = 0;
                rotationTargetAngle = -(val * Math.PI / 180);
                statusMsg.textContent = `Rotate ${val}° about origin.`;
            } 
            else if (type === 'reflect') {
                if (val === 'x') {
                    targetPoints = prePoints.map(p => ({ x: p.x, y: -p.y }));
                    statusMsg.textContent = "Reflect across X-axis.";
                } else if (val === 'y') {
                    targetPoints = prePoints.map(p => ({ x: -p.x, y: p.y }));
                    statusMsg.textContent = "Reflect across Y-axis.";
                } else if (val === 'custom') {
                    currentMode = 'reflect-line';
                    statusMsg.textContent = "Tap two points to define the line of reflection.";
                    closeModal();
                    return;
                }
            }
            switchWorkflow('img');
            closeModal();
        }

        function calculateCustomReflection() {
            if (!reflectionLine || reflectionLine.length < 2) return;
            const p1 = reflectionLine[0];
            const p2 = reflectionLine[1];
            targetPoints = prePoints.map(p => {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                if (dx === 0 && dy === 0) return p;
                const a = dy;
                const b = -dx;
                const c = dx * p1.y - dy * p1.x;
                const d = (a * p.x + b * p.y + c) / (a * a + b * b);
                return { x: p.x - 2 * a * d, y: p.y - 2 * b * d };
            });
            switchWorkflow('img');
        }

        function checkWork() {
            if (targetPoints.length === 0) {
                alert("Choose a transformation first!");
                return;
            }
            isAnimatingCheck = true;
            if (imgPoints.length !== targetPoints.length) {
                statusMsg.innerHTML = `<span class='text-amber-600 font-bold'>Point mismatch. Need ${targetPoints.length} points.</span>`;
                return;
            }
            let correctCount = 0;
            const threshold = 0.25; 
            targetPoints.forEach(tp => {
                const found = imgPoints.some(ip => Math.abs(ip.x - tp.x) < threshold && Math.abs(ip.y - tp.y) < threshold);
                if (found) correctCount++;
            });
            if (correctCount === targetPoints.length) {
                statusMsg.innerHTML = "<span class='text-emerald-600 font-bold'>Excellent! Correct!</span>";
            } else {
                statusMsg.innerHTML = `<span class='text-red-600 font-bold'>Try again: ${correctCount}/${targetPoints.length} correct.</span>`;
            }
        }

        function resize() {
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            origin.x = Math.floor(canvas.width / 2);
            origin.y = Math.floor(canvas.height / 2);
            const minDim = Math.min(canvas.width, canvas.height);
            gridSize = Math.max(18, Math.floor(minDim / 45)); 
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function toCartesian(pixelX, pixelY) {
            let rawX = (pixelX - origin.x) / gridSize;
            let rawY = (origin.y - pixelY) / gridSize;
            return {
                x: Math.round(rawX / SNAP) * SNAP,
                y: Math.round(rawY / SNAP) * SNAP
            };
        }

        function toPixels(cartX, cartY) {
            return { x: origin.x + (cartX * gridSize), y: origin.y - (cartY * gridSize) };
        }

        function handlePointerMove(e) {
            const pos = getMousePos(e);
            lastPointerPos = pos;
            const cart = toCartesian(pos.x, pos.y);
            valX.textContent = cart.x;
            valY.textContent = cart.y;
        }

        function handlePointerUp(e) {
            const pos = e ? getMousePos(e) : lastPointerPos;
            const cart = toCartesian(pos.x, pos.y);

            if (currentMode === 'reflect-line') {
                if (!reflectionLine) reflectionLine = [];
                reflectionLine.push(cart);
                if (reflectionLine.length === 2) calculateCustomReflection();
            }
            else {
                let list = currentMode === 'pre' ? prePoints : imgPoints;
                const existingIndex = list.findIndex(p => Math.abs(p.x - cart.x) < 0.2 && Math.abs(p.y - cart.y) < 0.2);
                if (existingIndex !== -1) list.splice(existingIndex, 1);
                else list.push(cart);
                isAnimatingCheck = false;
                isRotating = false;
            }
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Minor gridlines (0.5 units)
            ctx.beginPath();
            ctx.strokeStyle = '#f1f5f9';
            ctx.lineWidth = 0.5;
            for (let x = -20; x <= 20; x += 0.5) {
                const p = toPixels(x, 0); ctx.moveTo(p.x, 0); ctx.lineTo(p.x, canvas.height);
            }
            for (let y = -20; y <= 20; y += 0.5) {
                const p = toPixels(0, y); ctx.moveTo(0, p.y); ctx.lineTo(canvas.width, p.y);
            }
            ctx.stroke();

            // Major gridlines (1 unit)
            ctx.beginPath();
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            for (let x = -20; x <= 20; x += 1) {
                const p = toPixels(x, 0); ctx.moveTo(p.x, 0); ctx.lineTo(p.x, canvas.height);
            }
            for (let y = -20; y <= 20; y += 1) {
                const p = toPixels(0, y); ctx.moveTo(0, p.y); ctx.lineTo(canvas.width, p.y);
            }
            ctx.stroke();

            // Axes
            ctx.beginPath();
            ctx.strokeStyle = '#475569';
            ctx.lineWidth = 2;
            ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y);
            ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, canvas.height);
            ctx.stroke();

            // Axis labels
            ctx.fillStyle = '#94a3b8';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'center';
            for (let x = -20; x <= 20; x += 2) {
                if (x === 0) continue;
                const p = toPixels(x, 0); ctx.fillText(x, p.x, origin.y + 12);
            }
            ctx.textAlign = 'right';
            for (let y = -20; y <= 20; y += 2) {
                if (y === 0) continue;
                const p = toPixels(0, y); ctx.fillText(y, origin.x - 5, p.y + 3);
            }
        }

        function drawShape(list, color, labelPrefix, isClosed = true, alpha = 1) {
            if (list.length === 0) return;
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2.5;
            list.forEach((p, i) => {
                const pix = toPixels(p.x, p.y);
                if (i === 0) ctx.moveTo(pix.x, pix.y);
                else ctx.lineTo(pix.x, pix.y);
            });
            if(isClosed && list.length > 2) ctx.closePath();
            ctx.stroke();

            list.forEach((p, i) => {
                const pix = toPixels(p.x, p.y);
                // Draw point
                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.arc(pix.x, pix.y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw Label and Coordinates
                ctx.fillStyle = '#1e293b';
                ctx.textAlign = 'center';
                
                // Vertex Name (e.g., P1, P'1)
                ctx.font = 'bold 10px monospace';
                ctx.fillText(`${labelPrefix}${i+1}`, pix.x, pix.y - 18);
                
                // Cartesian Coordinates (e.g., (2, -3))
                ctx.font = '8px monospace';
                ctx.fillText(`(${p.x}, ${p.y})`, pix.x, pix.y - 8);
            });
            ctx.restore();
        }

        function draw() {
            drawGrid();
            
            if (reflectionLine) {
                ctx.beginPath();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 2;
                if (reflectionLine.length === 1) {
                    const p1 = toPixels(reflectionLine[0].x, reflectionLine[0].y);
                    ctx.arc(p1.x, p1.y, 3, 0, Math.PI*2);
                    ctx.fill();
                } else {
                    const dx = reflectionLine[1].x - reflectionLine[0].x;
                    const dy = reflectionLine[1].y - reflectionLine[0].y;
                    const start = toPixels(reflectionLine[0].x - dx*50, reflectionLine[0].y - dy*50);
                    const end = toPixels(reflectionLine[0].x + dx*50, reflectionLine[0].y + dy*50);
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            drawShape(prePoints, '#3b82f6', 'P');

            if (isRotating && prePoints.length > 0) {
                rotationProgress += 0.012; 
                if (rotationProgress > 1) rotationProgress = 1;
                const currentStepAngle = rotationTargetAngle * rotationProgress;
                const rotatingPoints = prePoints.map(p => {
                    const cos = Math.cos(currentStepAngle);
                    const sin = Math.sin(currentStepAngle);
                    return { x: p.x * cos - p.y * sin, y: p.x * sin + p.y * cos };
                });
                ctx.save();
                ctx.setLineDash([2, 4]);
                ctx.strokeStyle = 'rgba(148, 163, 184, 0.6)';
                prePoints.forEach(p => {
                    const radius = Math.sqrt(p.x*p.x + p.y*p.y) * gridSize;
                    const startAngle = -Math.atan2(p.y, p.x);
                    const endAngle = startAngle - currentStepAngle;
                    ctx.beginPath();
                    ctx.arc(origin.x, origin.y, radius, startAngle, endAngle, (rotationTargetAngle > 0));
                    ctx.stroke();
                });
                ctx.restore();
                drawShape(rotatingPoints, '#f59e0b', "R", true, 0.5);
            }

            if (isAnimatingCheck && targetPoints.length > 0) {
                const pulse = Math.sin(Date.now() / 150) * 5;
                drawShape(targetPoints, '#10b981', "T", true, 0.3);
                targetPoints.forEach((tp, i) => {
                    const pix = toPixels(tp.x, tp.y);
                    const threshold = 0.25;
                    const isCorrect = imgPoints.some(ip => Math.abs(ip.x - tp.x) < threshold && Math.abs(ip.y - tp.y) < threshold);
                    ctx.beginPath();
                    ctx.strokeStyle = isCorrect ? '#10b981' : '#f43f5e';
                    ctx.lineWidth = 2;
                    ctx.arc(pix.x, pix.y, 8 + pulse, 0, Math.PI * 2);
                    ctx.stroke();
                });
            }

            drawShape(imgPoints, '#ef4444', "P'");

            if (isHovering && !isRotating && !isAnimatingCheck) {
                const cart = toCartesian(lastPointerPos.x, lastPointerPos.y);
                const pix = toPixels(cart.x, cart.y);
                ctx.save();
                ctx.fillStyle = 'rgba(30, 41, 59, 0.8)';
                ctx.font = 'bold 11px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`(${cart.x}, ${cart.y})`, lastPointerPos.x, lastPointerPos.y - 15);
                ctx.beginPath();
                ctx.strokeStyle = '#3b82f6';
                ctx.setLineDash([2, 2]);
                ctx.arc(pix.x, pix.y, 6, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        window.onload = init;
    </script>
</body>
</html>
