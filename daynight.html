<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Solar Lab: External View</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; touch-action: none; }
        canvas { display: block; }
        .interface-layer { position: absolute; inset: 0; pointer-events: none; display: flex; flex-direction: column; padding: 15px; gap: 15px; }
        .ui-card { pointer-events: auto; background: rgba(10, 10, 15, 0.85); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.1); color: white; padding: 16px; border-radius: 20px; }
        .top-panel { width: 100%; max-width: 360px; }
        .bottom-panel { width: 100%; max-width: 360px; margin-top: auto; border-left: 4px solid #3b82f6; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.65rem; color: #9ca3af; text-transform: uppercase; letter-spacing: 0.15em; margin-bottom: 6px; font-weight: 700; }
        .season-btn { background: #1f2937; border: 1px solid #374151; padding: 10px 6px; border-radius: 10px; font-size: 0.75rem; transition: all 0.2s; color: #d1d5db; width: 100%; }
        .season-btn.active { background: #2563eb; border-color: #60a5fa; color: white; }
        .day-bar { height: 12px; border-radius: 6px; background: #111; overflow: hidden; display: flex; margin: 10px 0; border: 1px solid #333; }
        .day-fill { background: linear-gradient(90deg, #f59e0b, #fbbf24); height: 100%; transition: width 0.3s; }
        .night-fill { background: linear-gradient(90deg, #1e3a8a, #3b82f6); height: 100%; transition: width 0.3s; }
        input[type=range] { -webkit-appearance: none; background: transparent; width: 100%; }
        input[type=range]::-webkit-slider-runnable-track { background: #374151; height: 6px; border-radius: 3px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 18px; width: 18px; border-radius: 50%; background: #60a5fa; margin-top: -6px; border: 2px solid white; }
    </style>
</head>
<body>

    <div class="interface-layer">
        <div class="ui-card top-panel">
            <h1 class="text-xl font-black mb-3 italic tracking-tighter">SOLAR <span class="text-blue-500">LAB</span></h1>
            <div class="control-group">
                <label>Set Orbit Position</label>
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="setSeason('summer')" id="btn-summer" class="season-btn">June Solstice</button>
                    <button onclick="setSeason('autumn')" id="btn-autumn" class="season-btn">Sept Equinox</button>
                    <button onclick="setSeason('winter')" id="btn-winter" class="season-btn">Dec Solstice</button>
                    <button onclick="setSeason('spring')" id="btn-spring" class="season-btn">March Equinox</button>
                </div>
                <button onclick="setSeason('orbit')" id="btn-orbit" class="season-btn mt-2 active font-bold">▶ RESUME ORBIT</button>
            </div>
            <div class="space-y-4">
                <div class="control-group">
                    <div class="flex justify-between items-center mb-1">
                        <label class="mb-0">Marker Latitude</label>
                        <span id="latVal" class="text-[10px] font-mono text-blue-400">45°N</span>
                    </div>
                    <input type="range" id="latRange" min="-1.4" max="1.4" step="0.05" value="0.7">
                </div>
                <div class="control-group">
                    <label>Rotation Speed</label>
                    <input type="range" id="speedRange" min="0" max="10" step="0.5" value="2.5">
                </div>
            </div>
        </div>

        <div class="ui-card bottom-panel">
            <div class="flex items-center gap-2 mb-2">
                <div id="statusDot" class="w-3 h-3 rounded-full bg-yellow-400"></div>
                <div id="sunStatus" class="text-sm font-bold uppercase tracking-widest text-yellow-400">Daytime</div>
            </div>
            <div class="day-bar">
                <div id="dayFill" class="day-fill" style="width: 50%"></div>
                <div id="nightFill" class="night-fill" style="width: 50%"></div>
            </div>
            <div id="ratioText" class="text-xs font-mono text-gray-300">12.0h Day / 12.0h Night</div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, sun, earth, earthGroup, markerDot, earthContainer;
        let rotationSpeed = 0.025, orbitSpeed = 0.004, mode = 'orbit';
        let isUserInteracting = false, targetRotX = 0.5, targetRotY = 0.5, rotX = 0.5, rotY = 0.5, zoom = 60;
        let lx, ly;

        const AXIAL_TILT = 23.5 * (Math.PI / 180);
        const ORBIT_RADIUS = 30;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Light from the sun
            scene.add(new THREE.AmbientLight(0xffffff, 0.2));
            const sunLight = new THREE.PointLight(0xffffff, 3, 500);
            scene.add(sunLight);

            // The Sun
            sun = new THREE.Mesh(
                new THREE.SphereGeometry(4, 32, 32), 
                new THREE.MeshBasicMaterial({ color: 0xffcc33 })
            );
            scene.add(sun);

            // Orbit Path Ring
            const pathGeo = new THREE.RingGeometry(ORBIT_RADIUS - 0.1, ORBIT_RADIUS + 0.1, 128);
            const pathMat = new THREE.MeshBasicMaterial({ color: 0x444444, side: THREE.DoubleSide });
            const pathRing = new THREE.Mesh(pathGeo, pathMat);
            pathRing.rotation.x = Math.PI / 2;
            scene.add(pathRing);

            // Orbit Group
            earthGroup = new THREE.Group();
            scene.add(earthGroup);

            // Earth Container (for tilt)
            earthContainer = new THREE.Group();
            earthContainer.position.x = ORBIT_RADIUS;
            earthContainer.rotation.z = AXIAL_TILT; 
            earthGroup.add(earthContainer);

            // The Earth
            earth = new THREE.Mesh(
                new THREE.SphereGeometry(2, 64, 64),
                new THREE.MeshPhongMaterial({ color: 0x2266ff, shininess: 20 })
            );
            earthContainer.add(earth);

            // Marker
            markerDot = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            earth.add(markerDot);

            // Poles
            const axisLine = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 6), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }));
            earth.add(axisLine);

            createStars();
            setupInteractions();
            animate();
        }

        function createStars() {
            const geo = new THREE.BufferGeometry();
            const verts = [];
            for (let i = 0; i < 3000; i++) verts.push((Math.random()-0.5)*1000, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
            scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ color: 0x888888, size: 0.5 })));
        }

        function setupInteractions() {
            const move = (dx, dy) => {
                targetRotY += dx * 0.005;
                targetRotX += dy * 0.005;
                targetRotX = Math.max(0.1, Math.min(1.5, targetRotX)); // Prevent flipping over poles
            };
            window.addEventListener('mousedown', () => isUserInteracting = true);
            window.addEventListener('mouseup', () => isUserInteracting = false);
            window.addEventListener('mousemove', (e) => { if(isUserInteracting) move(e.movementX, e.movementY); });
            window.addEventListener('touchstart', (e) => { isUserInteracting = true; lx = e.touches[0].pageX; ly = e.touches[0].pageY; });
            window.addEventListener('touchmove', (e) => {
                if(!isUserInteracting) return;
                move(e.touches[0].pageX - lx, e.touches[0].pageY - ly);
                lx = e.touches[0].pageX; ly = e.touches[0].pageY;
            });
            window.addEventListener('touchend', () => isUserInteracting = false);
            window.addEventListener('wheel', (e) => { zoom = Math.max(20, Math.min(150, zoom + e.deltaY * 0.05)); });
        }

        function setSeason(s) {
            mode = s;
            document.querySelectorAll('.season-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + s).classList.add('active');
            if (s === 'summer') earthGroup.rotation.y = 0; 
            if (s === 'autumn') earthGroup.rotation.y = Math.PI/2;
            if (s === 'winter') earthGroup.rotation.y = Math.PI;
            if (s === 'spring') earthGroup.rotation.y = 3*Math.PI/2;
        }

        function updateLogic() {
            const lat = parseFloat(document.getElementById('latRange').value);
            markerDot.position.y = lat * 2.0; 
            const r = Math.sqrt(Math.max(0, 2.0*2.0 - markerDot.position.y*markerDot.position.y));
            markerDot.position.z = r; markerDot.position.x = 0;
            document.getElementById('latVal').innerText = `${Math.abs(Math.round(lat*60))}°${lat >= 0 ? 'N' : 'S'}`;

            // Calculate Day/Night relative to Sun
            const markerPos = new THREE.Vector3();
            markerDot.getWorldPosition(markerPos);
            const earthPos = new THREE.Vector3();
            earth.getWorldPosition(earthPos);

            const toMarker = markerPos.clone().sub(earthPos).normalize();
            const toSun = new THREE.Vector3(0,0,0).sub(earthPos).normalize();
            const dot = toMarker.dot(toSun);

            const sunStatus = document.getElementById('sunStatus');
            const statusDot = document.getElementById('statusDot');
            if (dot > 0) {
                sunStatus.innerText = "Daytime"; sunStatus.style.color = "#f59e0b";
                statusDot.className = "w-3 h-3 rounded-full bg-yellow-400 animate-pulse";
            } else {
                sunStatus.innerText = "Nighttime"; sunStatus.style.color = "#3b82f6";
                statusDot.className = "w-3 h-3 rounded-full bg-blue-600";
            }

            const tiltEff = Math.cos(earthGroup.rotation.y) * lat * 0.82;
            const dayP = Math.min(100, Math.max(0, 50 + (tiltEff * 45)));
            document.getElementById('dayFill').style.width = dayP + "%";
            document.getElementById('nightFill').style.width = (100 - dayP) + "%";
            document.getElementById('ratioText').innerText = `${(dayP * 0.24).toFixed(1)}h Day / ${((100-dayP) * 0.24).toFixed(1)}h Night`;
            rotationSpeed = 0.01 * document.getElementById('speedRange').value;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (mode === 'orbit') earthGroup.rotation.y += orbitSpeed;
            earth.rotation.y += rotationSpeed;

            rotX += (targetRotX - rotX) * 0.1;
            rotY += (targetRotY - rotY) * 0.1;

            // Camera is now fixed to Sun (0,0,0)
            camera.position.set(
                zoom * Math.sin(rotY) * Math.cos(rotX),
                zoom * Math.sin(rotX),
                zoom * Math.cos(rotY) * Math.cos(rotX)
            );
            camera.lookAt(0, 0, 0);

            updateLogic();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = init;
    </script>
</body>
</html>
